\documentclass[11pt,a4paper]{article}
\usepackage{times}

\begin{document}

\title{Critique on "LLVM: A compilation framework for lifelong program analysis \& transformation"~\cite{lattner2004llvm}}
\author{Junghoon Seo\\GIST}

\maketitle

\section{Summary}

This paper introduces the \textit{LLVM} compiler frame work for transparent, life-long program analysis and transformation. The two elements of LLVM, program representation and compiler architecture, are described in detail as follows. The LLVM code representation has the following key features. (A) A low-level, language-independent type system, (b) Type conversion instruction preserving type information (c) Two low-level exception-handling instructions. The LLVM compiler has a wide variety of components such as external front-end \& static optimizers, compile- and link-time optimizers, and offline or JIT native code generators to achieve the stated goals. Both experimentally and conceptually, LLVM provides a low-level but rich, compat, fast, retargetable, and retrospective representation and compile system.

\section{Strength}

LLVM is considered to have succeeded in binding the compiler environment, which was divided into a static compiler and a runtime / JIT compiler. Apart from its excellence, many sub-projects of LLVM, such as \textit{clang}, show a great deal of contribution from this paper.

\section{Weakness}

There is a somewhat lack of examples of code representation and type conversion in the paper. However, it is a fairly understandable part of the feature of the subject that the paper describes, which could be tricky like the API docs if authors start to write in detail.

\section{Conclusion}

LLVM is designed for compile-time, run-time, and static optimization for any language. LLVM provides a complete middle compiler layer using IR generated by the compiler and optimized IR. LLVM also generates relocatable naive code at run-time or at compile/link-time.

\bibliographystyle{plain}
\bibliography{critique}

\end{document}

